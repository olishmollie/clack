* Fig 

** Grammar

   <stmtlist> ::= <stmt>* | <assign_stmt>

   <assign_stmt> ::= <ident> '=' <stmt>

   <stmt>     ::= <expr> | <expr> '>' <expr> | <expr> '<' <expr> | <expr> '==' <expr>

   <expr>     ::= <term> | <term> '+' <term> | <term> '-' <term> 
   
   <term>     ::= <factor> | <factor> '*' <factor> | <factor> '/' <factor> 

   <factor>   ::= <digit> | <ident> | '(' <expr> ')'

   <ident>    ::= '\w+'

   <digit>    ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

** Tasks
*** DONE Refactor token creation.
    CLOSED: [2017-11-25 Sat 20:29]
    When adding a newline token, notice that you must add code to (at least) three places:
    - token definition in token.
    - chartype() in token.c
    - 'read_next(lexer*) in lexer.c
    We should strive for code that minimizes this.

*** DONE Handle EOF
    CLOSED: [2017-11-20 Mon 12:15]
    Right now, two newline characters are necessary to tell the interpreter that there is no
    more code to parse. We need to figure out how to end it with just one new line, or none.

** Notes
   How do we implement builtin functions, like print()? Possiblilites:
   - Interpreter maps ident tokens to builtin functions
   - Parser maps ident tokens and <call> becomes a factor
   - Lexer creates function token by checking a list of builtins
  
